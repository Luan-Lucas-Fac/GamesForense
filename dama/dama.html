<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Damas Emoji ‚Äî Hacker vs Agente</title>
  <style>
    :root {
      --bg: #1f1f1f;
      --board-border: #00f5ff;
      --light-cell: #f0d9b5;
      --dark-cell: #b58863;
      --accent: #ffd166;
      --win-color: #4CAF50;
      --lose-color: #f44336;
    }
    html, body {
      height: 100%;
      margin: 0;
      font-family: Segoe UI, Roboto, Arial;
      background: var(--bg);
      color: #fff;
    }
    .wrap {
      max-width: 820px;
      margin: 18px auto;
      padding: 6px;
      text-align: center;
    }
    h1 {
      font-size: 34px;
      margin: 8px 0 18px;
    }

    .controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-bottom: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    .controls select, .controls button {
      padding: 8px 12px;
      border-radius: 8px;
      border: none;
      background: #272727;
      color: #fff;
      cursor: pointer;
    }

    /* Tabuleiro: 8x8 com padr√£o de damas */
    .board-wrap {
      background: transparent;
      padding: 8px;
      border: 6px solid var(--board-border);
      border-radius: 8px;
      display: inline-block;
      position: relative;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(8, 64px);
      grid-template-rows: repeat(8, 64px);
      gap: 0;
      background: transparent;
    }
    .cell {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 34px;
      user-select: none;
      cursor: pointer;
      position: relative;
    }
    .cell.small {
      font-size: 26px;
    }

    /* Cores das c√©lulas do tabuleiro */
    .cell.light {
      background-color: var(--light-cell);
    }
    .cell.dark {
      background-color: var(--dark-cell);
    }

    .cell.highlight {
      outline: 3px solid rgba(255, 255, 255, 0.12);
      box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.02);
    }
    .cell.move {
      box-shadow: 0 0 0 3px rgba(0, 255, 170, 0.708) inset;
    }
    .cell.capture {
      box-shadow: 0 0 0 3px rgba(232, 9, 9, 0.786) inset;
    }
    .cell.required-capture {
      box-shadow: 0 0 0 3px rgba(255, 0, 0, 0.3) inset;
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 3px rgba(227, 4, 4, 0.875) inset; }
      50% { box-shadow: 0 0 0 3px rgba(255, 0, 0, 0.6) inset; }
      100% { box-shadow: 0 0 0 3px rgba(255, 0, 0, 0.845) inset; }
    }

    .info {
      margin-top: 12px;
    }
    .log {
      max-height: 120px;
      overflow: auto;
      background: #111;
      padding: 8px;
      border-radius: 6px;
      text-align: left;
      font-size: 13px;
    }
    .footer {
      margin-top: 10px;
      font-size: 13px;
      color: #bbb;
    }

    /* Efeitos de vit√≥ria e derrota */
    .win-effect {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1000;
      animation: confettiRain 10s forwards;
    }

    .lose-effect {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(244, 67, 54, 0.3);
      pointer-events: none;
      z-index: 1000;
      animation: blinkRed 10s forwards;
    }

    @keyframes confettiRain {
      0% {
        opacity: 1;
      }
      90% {
        opacity: 1;
      }
      100% {
        opacity: 0;
      }
    }

    @keyframes blinkRed {
      0%, 50% {
        opacity: 0.3;
      }
      25%, 75% {
        opacity: 0.6;
      }
      100% {
        opacity: 0;
      }
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #f00;
      opacity: 0.7;
      animation: fall linear forwards;
    }

    @keyframes fall {
      to {
        transform: translateY(100vh) rotate(360deg);
      }
    }

    .piece.king::after {
      content: "üëë";
      position: absolute;
      font-size: 16px;
      top: 2px;
      right: 2px;
    }

    @media (max-width: 640px) {
      .board {
        grid-template-columns: repeat(8, 40px);
        grid-template-rows: repeat(8, 40px);
      }
      .cell {
        font-size: 20px;
      }
      .piece.king::after {
        font-size: 10px;
        top: 1px;
        right: 1px;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Damas Emoji ‚Äî Hacker vs Agente</h1>

    <div class="controls">
      <label style="display:flex;gap:8px;align-items:center">
        Jogar como:
        <select id="sideSelect">
          <option value="agent">Agente Forense üïµüèª</option>
          <option value="hacker">Hacker üëæ</option>
        </select>
      </label>
      <label style="display:flex;gap:8px;align-items:center">
        Dificuldade:
        <select id="difficultySelect">
          <option value="easy">F√°cil</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Dif√≠cil</option>
        </select>
      </label>
      <button id="newBtn">Novo Jogo</button>
      <button id="undoBtn">Desfazer (1 passo)</button>
      <button id="resignBtn">Desistir</button>
    </div>

    <div class="board-wrap">
      <div id="board" class="board" role="grid" aria-label="Tabuleiro de damas"></div>
      
    </div>

    <div class="info">
      <div id="status">Status: aguardando novo jogo</div>
      <div class="log" id="log"></div>
      <div class="footer">
        Regras: Pe√ßas se movem apenas nas casas escuras. Capturas s√£o obrigat√≥rias. 
        Pe√ßas viram damas (com üëë) quando alcan√ßam o lado oposto do tabuleiro.
      </div>
    </div>
    
  </div>

  <script>
    // =====================
    // Jogo de Damas com emojis
    // - Cada pe√ßa tem: side ('agent' ou 'hacker') e isKing (booleano)
    // - Movimento segue regras de damas internacionais
    // - Exibe emojis por lado: agent -> üïµüèª, hacker -> üëæ
    // - IA joga seguindo as regras de damas
    // =====================

    // Helpers
    const $ = id => document.getElementById(id);
    const log = msg => {const el=$('log'); el.innerHTML = msg + '<br>' + el.innerHTML; }

    // Configura√ß√µes e estado
    const EMOJI = {agent:'üïµüèª', hacker:'üëæ'};
    let boardEl = $('board');
    let playerSide = 'agent';
    let gameState = null;
    let selected = null;
    let history = [];
    let difficulty = 'normal';
    let forcedCapturePiece = null;

    // Cria c√©lulas do tabuleiro (8x8) com padr√£o de damas
    function createBoardCells(){
      boardEl.innerHTML = '';
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const cell = document.createElement('div');
          // Alterna entre c√©lulas claras e escuras (apenas escuras s√£o jog√°veis)
          cell.className = 'cell ' + ((r + c) % 2 === 0 ? 'light' : 'dark');
          cell.dataset.r = r; 
          cell.dataset.c = c;
          cell.id = `cell-${r}-${c}`;
          cell.addEventListener('click', onCellClick);
          boardEl.appendChild(cell);
        }
      }
    }

    // Inicializa posi√ß√£o padr√£o de damas
    function initGame(){
      // Matriz 8x8: cada c√©lula ou null ou {side:'agent'|'hacker', isKing:false}
      const g = Array.from({length: 8}, () => Array(8).fill(null));
      
      // Posiciona pe√ßas do hacker (topo)
      for(let r=0; r<3; r++){
        for(let c=0; c<8; c++){
          if((r + c) % 2 === 1){ // Apenas casas escuras
            g[r][c] = {side: 'hacker', isKing: false};
          }
        }
      }
      
      // Posiciona pe√ßas do agent (base)
      for(let r=5; r<8; r++){
        for(let c=0; c<8; c++){
          if((r + c) % 2 === 1){ // Apenas casas escuras
            g[r][c] = {side: 'agent', isKing: false};
          }
        }
      }
      
      gameState = {board: g, turn: 'agent'};
      selected = null; 
      history = [];
      forcedCapturePiece = null;
      render();
      $('status').innerText = 'Status: jogo iniciado. Jogador: ' + (playerSide==='agent' ? 'Agente üïµüèª' : 'Hacker üëæ');
      log('Novo jogo iniciado. ' + (playerSide==='agent' ? 'Voc√™ √© Agente üïµüèª' : 'Voc√™ √© Hacker üëæ'));
      checkForcedCaptures();
    }

    // Renderiza o tabuleiro na tela
    function render(){
      for(let r=0;r<8;r++){
        for(let c=0;c<8;c++){
          const cell = $(`cell-${r}-${c}`);
          const piece = gameState.board[r][c];
          cell.innerText = '';
          cell.classList.remove('highlight', 'move', 'capture', 'required-capture', 'piece', 'king');
          
          if(piece){
            // Mostra emoji de acordo com o lado
            const emoji = piece.side === 'agent' ? EMOJI.agent : EMOJI.hacker;
            cell.innerText = emoji;
            cell.classList.add('piece');
            if(piece.isKing) {
              cell.classList.add('king');
            }
            cell.title = piece.side + (piece.isKing ? ' (Dama)' : '');
          } else {
            cell.title = '';
          }
        }
      }
      
      // Destaca pe√ßa com captura obrigat√≥ria
      if(forcedCapturePiece) {
        const cell = $(`cell-${forcedCapturePiece[0]}-${forcedCapturePiece[1]}`);
        if(cell) cell.classList.add('required-capture');
      }
    }

    // Verifica se as coordenadas est√£o dentro do tabuleiro
    function inside(r,c){ return r>=0 && r<8 && c>=0 && c<8 }

    // Gera todos os movimentos poss√≠veis para uma pe√ßa
    function genMovesFor(r, c) {
      const piece = gameState.board[r][c];
      if(!piece) return {moves: [], captures: []};

      const moves = [];
      const captures = [];
      const enemy = piece.side === 'agent' ? 'hacker' : 'agent';
      
      // Dire√ß√µes baseadas no tipo de pe√ßa
      let directions = [];
      if(piece.isKing) {
        // Damas podem se mover em todas as 4 diagonais
        directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
      } else {
        // Pe√ßas normais se movem apenas para frente (relativo ao lado)
        directions = piece.side === 'agent' ? [[-1, -1], [-1, 1]] : [[1, -1], [1, 1]];
      }

      // Verifica movimentos simples
      for(const [dr, dc] of directions) {
        const nr = r + dr, nc = c + dc;
        if(inside(nr, nc) && !gameState.board[nr][nc] && (nr + nc) % 2 === 1) {
          moves.push([nr, nc, []]); // [destino_r, destino_c, pe√ßas capturadas]
        }
      }

      // Verifica capturas (movimento obrigat√≥rio)
      for(const [dr, dc] of directions) {
        const nr = r + dr, nc = c + dc;
        const nr2 = r + 2*dr, nc2 = c + 2*dc;
        
        if(inside(nr, nc) && inside(nr2, nc2) && 
           gameState.board[nr][nc] && 
           gameState.board[nr][nc].side === enemy &&
           !gameState.board[nr2][nc2] &&
           (nr2 + nc2) % 2 === 1) {
          
          captures.push([nr2, nc2, [[nr, nc]]]); // [destino, [pe√ßas capturadas]]
          
          // Para damas: capturas m√∫ltiplas
          if(piece.isKing) {
            findMultipleCaptures(r, c, [[nr, nc]], captures, piece.side);
          }
        }
      }

      return {moves, captures};
    }

    // Encontra capturas m√∫ltiplas para damas
    function findMultipleCaptures(startR, startC, capturedSoFar, results, side) {
      const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
      const enemy = side === 'agent' ? 'hacker' : 'agent';
      
      for(const [dr, dc] of directions) {
        // Encontra uma pe√ßa inimiga
        let r = startR, c = startC;
        let foundEnemy = null;
        
        while(true) {
          r += dr;
          c += dc;
          if(!inside(r, c)) break;
          
          if(gameState.board[r][c]) {
            if(gameState.board[r][c].side === enemy && 
               !capturedSoFar.some(([cr, cc]) => cr === r && cc === c)) {
              foundEnemy = [r, c];
            }
            break;
          }
        }
        
        if(foundEnemy) {
          // Verifica se pode pular sobre a pe√ßa inimiga
          const [er, ec] = foundEnemy;
          const landR = er + dr, landC = ec + dc;
          
          if(inside(landR, landC) && !gameState.board[landR][landC] && 
             (landR + landC) % 2 === 1) {
            
            const newCaptured = [...capturedSoFar, [er, ec]];
            results.push([landR, landC, newCaptured]);
            
            // Continua buscando mais capturas
            findMultipleCaptures(landR, landC, newCaptured, results, side);
          }
        }
      }
    }

    // Verifica se h√° capturas obrigat√≥rias para o jogador atual
    function checkForcedCaptures() {
      const currentSide = gameState.turn;
      forcedCapturePiece = null;
      
      for(let r=0; r<8; r++){
        for(let c=0; c<8; c++){
          const piece = gameState.board[r][c];
          if(piece && piece.side === currentSide) {
            const {captures} = genMovesFor(r, c);
            if(captures.length > 0) {
              forcedCapturePiece = [r, c];
              return;
            }
          }
        }
      }
    }

    // Verifica turno do jogador e IA
    function onCellClick(e){
      const r = parseInt(e.currentTarget.dataset.r), c = parseInt(e.currentTarget.dataset.c);
      
      // S√≥ c√©lulas escuras s√£o jog√°veis
      if((r + c) % 2 === 0) return;
      
      const piece = gameState.board[r][c];
      
      // S√≥ permite sele√ß√£o se turno √© de quem controla o UI
      if(gameState.turn === playerSide){
        if(selected){
          // Se houver sele√ß√£o, tenta mover para aqui
          const [sr, sc] = selected;
          const {moves, captures} = genMovesFor(sr, sc);
          
          // Verifica se √© um movimento v√°lido
          let isValidMove = false;
          let isCapture = false;
          let capturePath = [];
          
          // Primeiro verifica capturas (obrigat√≥rias)
          if(captures.length > 0) {
            for(const [tr, tc, path] of captures) {
              if(tr === r && tc === c) {
                isValidMove = true;
                isCapture = true;
                capturePath = path;
                break;
              }
            }
          }
          
          // Se n√£o h√° capturas obrigat√≥rias, verifica movimentos simples
          if(!isValidMove && captures.length === 0) {
            for(const [tr, tc] of moves) {
              if(tr === r && tc === c) {
                isValidMove = true;
                break;
              }
            }
          }
          
          if(isValidMove) {
            makeMove(sr, sc, r, c, isCapture, capturePath);
            selected = null;
            clearHighlights();
            render();
            maybeAIMove();
            return;
          }
          
          // Se clicar em uma pe√ßa sua diferente, troca sele√ß√£o
          if(piece && piece.side === playerSide) {
            // S√≥ permite selecionar pe√ßas com movimentos v√°lidos
            const {moves, captures} = genMovesFor(r, c);
            if(moves.length > 0 || captures.length > 0) {
              selected = [r, c];
              highlightMoves(r, c);
            }
          } else {
            selected = null;
            clearHighlights();
          }
        } else {
          // Sem sele√ß√£o, se clicar numa pe√ßa sua, seleciona
          if(piece && piece.side === playerSide) {
            // S√≥ permite selecionar pe√ßas com movimentos v√°lidos
            const {moves, captures} = genMovesFor(r, c);
            if(moves.length > 0 || captures.length > 0) {
              selected = [r, c];
              highlightMoves(r, c);
            }
          }
        }
      }
    }

    function clearHighlights(){ 
      document.querySelectorAll('.cell').forEach(n => n.classList.remove('highlight','move','capture')); 
    }

    // Mostra movimentos poss√≠veis para uma pe√ßa
    function highlightMoves(r, c) {
      clearHighlights(); 
      const cell = $(`cell-${r}-${c}`); 
      if(!cell) return; 
      
      cell.classList.add('highlight'); 
      const {moves, captures} = genMovesFor(r, c);
      
      // Destaca capturas (prioridade)
      captures.forEach(([tr, tc]) => {
        const el = $(`cell-${tr}-${tc}`);
        if(el) el.classList.add('capture');
      });
      
      // Destaca movimentos simples (apenas se n√£o houver capturas)
      if(captures.length === 0) {
        moves.forEach(([tr, tc]) => {
          const el = $(`cell-${tr}-${tc}`);
          if(el) el.classList.add('move');
        });
      }
    }

    // Executa um movimento
    function makeMove(sr, sc, tr, tc, isCapture = false, capturePath = []) {
      const piece = gameState.board[sr][sc];
      if(!piece) return;

      // Salva hist√≥rico para desfazer
      history.push(JSON.parse(JSON.stringify(gameState)));
      
      // Move a pe√ßa
      gameState.board[tr][tc] = piece;
      gameState.board[sr][sc] = null;
      
      // Remove pe√ßas capturadas
      if(isCapture) {
        capturePath.forEach(([cr, cc]) => {
          gameState.board[cr][cc] = null;
        });
      }
      
      // Promo√ß√£o a dama
      if(!piece.isKing) {
        if((piece.side === 'agent' && tr === 0) || (piece.side === 'hacker' && tr === 7)) {
          piece.isKing = true;
          log(`${piece.side} promovido a dama!`);
        }
      }
      
      // Verifica se h√° mais capturas poss√≠veis com a mesma pe√ßa
      let hasMoreCaptures = false;
      if(isCapture) {
        const {captures} = genMovesFor(tr, tc);
        hasMoreCaptures = captures.length > 0;
      }
      
      // Troca turno apenas se n√£o houver mais capturas
      if(!hasMoreCaptures) {
        gameState.turn = (gameState.turn === 'agent' ? 'hacker' : 'agent');
        checkForcedCaptures();
      }
      
      render();
      
      // Log do movimento
      let moveLog = `${piece.side} de (${sr},${sc}) -> (${tr},${tc})`;
      if(isCapture) {
        moveLog += ` capturou ${capturePath.length} pe√ßa(s)`;
      }
      if(piece.isKing) {
        moveLog += ' [DAMA]';
      }
      log(moveLog);
      
      $('status').innerText = `Status: turno de ${gameState.turn}${gameState.turn === playerSide ? ' ‚Äî sua vez.' : ' ‚Äî IA jogando...'}`;
      
      // Verifica se o jogo terminou
      checkGameEnd();
    }

    // Verifica se o jogo terminou
    function checkGameEnd() {
      let agentPieces = 0;
      let hackerPieces = 0;
      let agentHasMoves = false;
      let hackerHasMoves = false;
      
      // Conta pe√ßas e verifica movimentos poss√≠veis
      for(let r=0; r<8; r++){
        for(let c=0; c<8; c++){
          const piece = gameState.board[r][c];
          if(piece) {
            if(piece.side === 'agent') {
              agentPieces++;
              const {moves, captures} = genMovesFor(r, c);
              if(moves.length > 0 || captures.length > 0) agentHasMoves = true;
            } else {
              hackerPieces++;
              const {moves, captures} = genMovesFor(r, c);
              if(moves.length > 0 || captures.length > 0) hackerHasMoves = true;
            }
          }
        }
      }
      
      // Verifica condi√ß√µes de vit√≥ria
      if(agentPieces === 0 || !agentHasMoves) {
        endGame('hacker'); // Hacker venceu
      } else if(hackerPieces === 0 || !hackerHasMoves) {
        endGame('agent'); // Agente venceu
      }
    }

    // Finaliza o jogo com efeitos visuais
    function endGame(winner) {
      if(winner === playerSide) {
        // Jogador venceu - efeito de confete
        createConfetti();
        log('üéâ Parab√©ns! Voc√™ venceu! üéâ');
        $('status').innerText = 'Status: Voc√™ venceu!';
      } else {
        // Jogador perdeu - efeito vermelho piscante
        createLoseEffect();
        log('üíÄ Voc√™ perdeu! Tente novamente. üíÄ');
        $('status').innerText = 'Status: Voc√™ perdeu!';
      }
      
      // Reinicia o jogo ap√≥s 10 segundos
      setTimeout(() => {
        initGame();
        // Se jogador escolheu ser hacker e for turno do agent, IA joga primeiro
        if(gameState.turn !== playerSide) maybeAIMove();
      }, 10000);
    }

    // Cria efeito de confete para vit√≥ria
    function createConfetti() {
      const confettiContainer = document.createElement('div');
      confettiContainer.className = 'win-effect';
      document.body.appendChild(confettiContainer);
      
      // Cria m√∫ltiplos confetes
      for(let i = 0; i < 150; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        
        // Posi√ß√£o aleat√≥ria no topo
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.top = '-10px';
        
        // Cor aleat√≥ria
        const colors = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        
        // Tamanho aleat√≥rio
        const size = Math.random() * 10 + 5;
        confetti.style.width = size + 'px';
        confetti.style.height = size + 'px';
        
        // Dura√ß√£o e delay aleat√≥rios
        const duration = Math.random() * 3 + 7;
        const delay = Math.random() * 5;
        confetti.style.animationDuration = duration + 's';
        confetti.style.animationDelay = delay + 's';
        
        confettiContainer.appendChild(confetti);
      }
      
      // Remove o container ap√≥s a anima√ß√£o
      setTimeout(() => {
        document.body.removeChild(confettiContainer);
      }, 10000);
    }

    // Cria efeito vermelho piscante para derrota
    function createLoseEffect() {
      const loseEffect = document.createElement('div');
      loseEffect.className = 'lose-effect';
      document.body.appendChild(loseEffect);
      
      // Remove o efeito ap√≥s a anima√ß√£o
      setTimeout(() => {
        document.body.removeChild(loseEffect);
      }, 10000);
    }

    // IA: escolhe movimento seguindo as regras de damas
    function aiMakeMove(){
      const side = gameState.turn;
      const allMoves = [];
      const allCaptures = [];
      
      // Coleta todos os movimentos poss√≠veis
      for(let r=0; r<8; r++){
        for(let c=0; c<8; c++){
          const piece = gameState.board[r][c];
          if(piece && piece.side === side){
            const {moves, captures} = genMovesFor(r, c);
            
            // Capturas t√™m prioridade
            captures.forEach(capture => {
              allCaptures.push({
                from: [r, c],
                to: [capture[0], capture[1]],
                captures: capture[2],
                isCapture: true,
                piece: piece
              });
            });
            
            // Movimentos simples (apenas se n√£o houver capturas)
            if(captures.length === 0) {
              moves.forEach(move => {
                allMoves.push({
                  from: [r, c],
                  to: [move[0], move[1]],
                  captures: [],
                  isCapture: false,
                  piece: piece
                });
              });
            }
          }
        }
      }
      
      // Se n√£o h√° movimentos, jogo termina
      if(allCaptures.length === 0 && allMoves.length === 0) {
        $('status').innerText = 'Status: jogo terminado ‚Äî sem movimentos para ' + side;
        log('Sem movimentos para ' + side);
        return;
      }
      
      // Escolhe movimento baseado na dificuldade
      let selectedMove;
      
      if(allCaptures.length > 0) {
        // Sempre prioriza capturas
        if(difficulty === 'easy') {
          // F√°cil: escolhe captura aleat√≥ria
          selectedMove = allCaptures[Math.floor(Math.random() * allCaptures.length)];
        } else if(difficulty === 'hard') {
          // Dif√≠cil: prioriza capturas que resultam em dama ou capturam damas
          const scoredCaptures = allCaptures.map(move => {
            let score = move.captures.length; // Mais capturas = melhor
            
            // Bonus por capturar damas
            move.captures.forEach(([cr, cc]) => {
              if(gameState.board[cr][cc].isKing) score += 3;
            });
            
            // Bonus por se tornar dama
            const [tr, tc] = move.to;
            if(!move.piece.isKing && 
               ((side === 'agent' && tr === 0) || (side === 'hacker' && tr === 7))) {
              score += 2;
            }
            
            return {move, score};
          });
          
          scoredCaptures.sort((a, b) => b.score - a.score);
          selectedMove = scoredCaptures[0].move;
        } else {
          // Normal: escolhe captura com mais pe√ßas capturadas
          selectedMove = allCaptures.reduce((best, current) => 
            current.captures.length > best.captures.length ? current : best
          );
        }
      } else {
        // Movimentos simples
        if(difficulty === 'easy') {
          // F√°cil: movimento aleat√≥rio
          selectedMove = allMoves[Math.floor(Math.random() * allMoves.length)];
        } else if(difficulty === 'hard') {
          // Dif√≠cil: prioriza movimentos que avan√ßam para se tornar dama
          const scoredMoves = allMoves.map(move => {
            let score = 0;
            const [tr, tc] = move.to;
            
            // Avan√ßar para se tornar dama
            if(!move.piece.isKing) {
              if(side === 'agent' && tr < 4) score += (7 - tr); // Quanto mais perto do topo, melhor
              if(side === 'hacker' && tr > 3) score += tr; // Quanto mais perto da base, melhor
            }
            
            // Movimentos de dama para o centro
            if(move.piece.isKing) {
              const centerDist = Math.abs(3.5 - tr) + Math.abs(3.5 - tc);
              score += (7 - centerDist); // Mais perto do centro = melhor
            }
            
            return {move, score};
          });
          
          scoredMoves.sort((a, b) => b.score - a.score);
          selectedMove = scoredMoves[0].move;
        } else {
          // Normal: movimento aleat√≥rio
          selectedMove = allMoves[Math.floor(Math.random() * allMoves.length)];
        }
      }
      
      makeMove(
        selectedMove.from[0], selectedMove.from[1],
        selectedMove.to[0], selectedMove.to[1],
        selectedMove.isCapture,
        selectedMove.captures
      );
    }

    // Ap√≥s jogador mover, se for vez da IA, executa com pequeno delay visual
    function maybeAIMove(){
      if(gameState.turn !== playerSide){
        setTimeout(() => { 
          aiMakeMove(); 
          $('status').innerText = 'Status: turno de ' + gameState.turn + 
            (gameState.turn === playerSide ? ' ‚Äî sua vez.' : ' ‚Äî IA jogando...'); 
        }, 350);
      }
    }

    // Eventos dos bot√µes
    $('newBtn').addEventListener('click', ()=>{
      playerSide = $('sideSelect').value === 'agent' ? 'agent' : 'hacker';
      difficulty = $('difficultySelect').value;
      initGame();
      // Se jogador escolheu ser hacker e for turno do agent, IA joga primeiro
      if(gameState.turn !== playerSide) maybeAIMove();
    });
    
    $('undoBtn').addEventListener('click', ()=>{
      if(history.length === 0) return; 
      gameState = history.pop(); 
      render(); 
      $('status').innerText = 'Desfeito. Turno: ' + gameState.turn; 
      log('Desfeita √∫ltima jogada.'); 
    });
    
    $('resignBtn').addEventListener('click', ()=>{ 
      log('Jogador desistiu.'); 
      $('status').innerText = 'Voc√™ desistiu.'; 
      createBoardCells(); 
      gameState = {board: Array.from({length:8}, () => Array(8).fill(null)), turn: 'agent'}; 
      render(); 
    });

    // Inicializa√ß√£o da interface
    createBoardCells();
  </script>
</body>
</html>